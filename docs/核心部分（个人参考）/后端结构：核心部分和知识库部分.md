# 后端结构学习
HTTP Request
    ↓
Controller (接收DTO/VO，调用Service)
    ↓
Service (处理业务逻辑，使用Entity)
    ↓
Entity (数据模型，对应数据库表结构)
    ↓
Mapper (操作Entity对象)
    ↓
Mapper.xml (SQL映射Entity字段)
    ↓
Database


# 知识库部分
假设技术栈：Spring Boot + MyBatis-Plus + MySQL + Milvus。

## 知识库上传与向量化流程
HTTP Request (上传文档/知识)
    ↓
KnowledgeController (接收UploadReqDTO，返回UploadRespVO)
    ↓
KnowledgeService (处理文档解析、文本分块、调用向量化服务)
    ↓
Entity (KnowledgeChunkEntity 知识块实体，对应MySQL表)
    ↓
KnowledgeChunkMapper (操作KnowledgeChunkEntity对象)
    ↓
Mapper.xml (SQL映射KnowledgeChunkEntity字段)
    ↓
MySQL (存储原始知识块、元数据)
    ↓
VectorService (调用Embedding模型，生成向量)
    ↓
MilvusService (将向量存入Milvus向量数据库)
    ↓
Milvus (存储向量、关联KnowledgeChunkEntity的id)

## 智能问答检索流程
HTTP Request (用户问题)
    ↓
ChatController (接收QueryReqDTO，返回QueryRespVO)
    ↓
ChatService (处理业务逻辑，调用检索服务)
    ↓
RetrievalService (将问题向量化，进行相似度检索)
    ↓
MilvusService (在Milvus中执行向量相似度搜索)
    ↓
Milvus (返回最相似的向量ID列表)
    ↓
KnowledgeChunkMapper (根据返回的ID列表，查询原始知识内容)
    ↓
MySQL (返回对应的原始知识块)
    ↓
LLMService (组装提示词，调用大语言模型API)
    ↓
OpenAI / 文心一言 / 通义千问等 (生成最终答案)
    ↓
ChatService (处理并返回答案，可能包含溯源信息)

---

## 向量数据库（pgvector）与 Embedding 服务配置

- pgvector（PostgreSQL）服务：
  - Docker service 名：`pgvector-test`
  - 容器内地址（给后端用）：`jdbc:postgresql://pgvector-test:5432/vector_db`
  - 对外端口映射：宿主机 `5433` → 容器 `5432`
  - 数据库名：`vector_db`
  - 用户名：`vector_user`
  - 密码：`vector_pass_123`

- Embedding 服务（sentence-transformers，BAAI/bge-small-zh-v1.5）：
  - Docker service 名：`embedding-service`
  - 容器内访问地址：`http://embedding-service:9000`
  - 健康检查接口：`GET /health`
  - 向量接口：`POST /embeddings`，请求体包含 `{"input": ["文本1", "文本2", ...]}`，返回每条文本对应的 `embedding` 数组。

后端 RAG 流程中：
- 知识上传时：后端从 `embedding-service` 获取 512 维向量，写入 pgvector 的 `kb_chunk.embedding`。
- 检索时：后端对用户问题向量化，再用 pgvector 的 `<->` 相似度搜索获取最相关的内容片段。
