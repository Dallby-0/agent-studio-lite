# 重写工作流系统完整计划（前后端+数据库）

## 一、整体架构设计

### 核心思想

将工作流的节点、边等图结构数据统一存储为JSON格式，直接在前后端间传输，简化数据流转和存储逻辑。

### 数据流转

* **前端到后端**：前端构建完整的工作流JSON对象，直接传递给后端API

* **后端到前端**：后端返回包含完整JSON定义的工作流对象，前端直接使用

* **存储**：后端将工作流JSON存储到数据库的`definition`字段中

## 二、新工作流JSON结构设计

```json
{
  "id": 1,
  "name": "示例工作流",
  "description": "这是一个示例工作流",
  "version": "1.0.0",
  "status": 1,
  "createdBy": 1,
  "createdAt": "2023-01-01T00:00:00Z",
  "updatedAt": "2023-01-01T00:00:00Z",
  "isDeleted": 0,
  "definition": {
    "nodes": [
      {
        "id": 1,
        "name": "开始节点",
        "type": "start",
        "position": {
          "x": 100,
          "y": 200
        },
        "config": {}
      },
      {
        "id": 2,
        "name": "大模型调用",
        "type": "llm_call",
        "position": {
          "x": 300,
          "y": 200
        },
        "config": {
          "systemPrompt": "你是一个AI助手",
          "userPrompt": "请回答：${question}",
          "outputVar": "answer"
        }
      },
      {
        "id": 3,
        "name": "结束节点",
        "type": "end",
        "position": {
          "x": 500,
          "y": 200
        },
        "config": {}
      }
    ],
    "edges": [
      {
        "id": 1,
        "fromNodeId": 1,
        "toNodeId": 2
      },
      {
        "id": 2,
        "fromNodeId": 2,
        "toNodeId": 3
      }
    ]
  }
}
```

## 三、数据库设计（重写init.sql）

### 1. 移除冗余表

* 删除 `workflow_node` 表（不再需要）

* 删除 `workflow_edge` 表（不再需要）

### 2. 更新工作流表

在 `workflow` 表中添加 `definition` 字段，用于存储完整的工作流JSON定义。

```sql
-- 工作流表
CREATE TABLE `workflow` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '工作流ID',
  `name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '工作流名称',
  `description` text COLLATE utf8mb4_unicode_ci COMMENT '工作流描述',
  `version` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '1.0.0' COMMENT '版本号',
  `status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '状态 0-禁用 1-启用',
  `definition` json NOT NULL COMMENT '工作流完整定义（JSON格式）',
  `created_by` bigint NOT NULL COMMENT '创建者ID',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`),
  KEY `idx_created_by` (`created_by`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='工作流表';
```

### 3. 其他表保持不变

* `workflow_instance` 表

* `workflow_execution_log` 表

* 其他相关表

## 四、后端实现（重写）

### 1. Workflow实体类

* 添加 `definition` 字段，类型为 `String` 或 `JsonNode`

* 移除与 `workflow_node` 和 `workflow_edge` 的关联

### 2. WorkflowServiceImpl.java 重写

#### 核心方法调整

```java
// 创建工作流
@Override
@Transactional
public Workflow createWorkflow(Workflow workflow) {
    // 设置默认值和元数据
    if (workflow.getStatus() == null) workflow.setStatus(1);
    if (workflow.getVersion() == null) workflow.setVersion("1.0.0");
    workflow.setCreatedBy(getCurrentUserId());
    workflow.setCreatedAt(new Date());
    workflow.setUpdatedAt(new Date());
    
    // 直接插入工作流（definition字段已包含完整定义）
    workflowMapper.insertWorkflow(workflow);
    return workflow;
}

// 更新工作流
@Override
@Transactional
public Workflow updateWorkflow(Workflow workflow) {
    // 设置默认值和元数据
    if (workflow.getStatus() == null) workflow.setStatus(1);
    workflow.setUpdatedAt(new Date());
    
    // 直接更新工作流
    workflowMapper.updateWorkflow(workflow);
    return workflow;
}

// 获取工作流定义
@Override
public Workflow getWorkflowDefinition(Long workflowId) {
    return workflowMapper.getWorkflowById(workflowId);
}
```

### 3. WorkflowController.java 重写

#### API调整

* 简化API参数，直接接收/返回完整工作流对象

* 移除对节点和边的单独处理

```java
// 创建工作流
@PostMapping
public ApiResponse<Workflow> createWorkflow(@RequestBody Workflow workflow) {
    Workflow createdWorkflow = workflowService.createWorkflow(workflow);
    return ApiResponse.success(createdWorkflow);
}

// 更新工作流
@PutMapping("/{id}")
public ApiResponse<Workflow> updateWorkflow(@PathVariable Long id, @RequestBody Workflow workflow) {
    workflow.setId(id);
    Workflow updatedWorkflow = workflowService.updateWorkflow(workflow);
    return ApiResponse.success(updatedWorkflow);
}

// 获取工作流定义
@GetMapping("/{id}")
public ApiResponse<Workflow> getWorkflowDefinition(@PathVariable Long id) {
    Workflow workflow = workflowService.getWorkflowDefinition(id);
    return ApiResponse.success(workflow);
}
```

### 4. WorkflowMapper调整

* 更新SQL语句，移除对 `workflow_node` 和 `workflow_edge` 表的操作

* 简化查询，直接返回包含 `definition` 字段的工作流对象

## 五、前端实现（重写）

### 1. WorkflowDesigner.vue 重写

#### 数据结构适配

* 内部状态与新JSON结构对齐

* 节点使用 `position` 对象存储坐标

* 节点配置直接使用 `config` 对象

#### 保存逻辑优化

```javascript
// 保存工作流
const saveWorkflow = () => {
  // 验证工作流
  const startNodes = nodes.value.filter(n => n.type === 'start')
  const endNodes = nodes.value.filter(n => n.type === 'end')
  
  if (!workflowName.value.trim()) {
    ElMessage.warning('请输入工作流名称')
    return
  }
  if (startNodes.length === 0) {
    ElMessage.warning('工作流必须包含一个开始节点')
    return
  }
  if (endNodes.length === 0) {
    ElMessage.warning('工作流必须包含一个结束节点')
    return
  }
  
  // 构建完整的工作流JSON对象
  const workflowData = {
    id: props.workflow.id,
    name: workflowName.value,
    description: workflowDescription.value,
    version: workflowVersion.value,
    status: props.workflow.status !== undefined ? props.workflow.status : 1,
    createdBy: props.workflow.createdBy,
    createdAt: props.workflow.createdAt,
    updatedAt: new Date().toISOString(),
    isDeleted: props.workflow.isDeleted !== undefined ? props.workflow.isDeleted : 0,
    // 直接构建definition字段
    definition: {
      nodes: nodes.value,
      edges: edges.value
    }
  }
  
  emit('save', workflowData)
  ElMessage.success('工作流已保存')
}
```

### 2. WorkflowDesignerView\.vue 重写

#### API调用简化

```javascript
// 处理保存工作流事件
const onSaveWorkflow = (workflowData) => {
  isSaving.value = true
  
  const savePromise = isEditing.value 
    ? updateWorkflow(workflowData.id, workflowData)
    : createWorkflow(workflowData)
  
  savePromise.then(response => {
    ElMessage.success('工作流已保存')
    workflow.value = response.data // 直接使用完整的工作流对象
    isEditing.value = true
  }).catch(error => {
    ElMessage.error('保存工作流失败')
    console.error('保存工作流失败:', error)
  }).finally(() => {
    isSaving.value = false
  })
}

// 加载工作流定义
const loadWorkflowDefinition = (id) => {
  getWorkflowDefinition(id).then(response => {
    // 直接使用后端返回的完整工作流对象
    workflow.value = response.data
  }).catch(error => {
    ElMessage.error('加载工作流失败')
    console.error('加载工作流失败:', error)
  })
}
```

### 3. workflow\.js API 更新

```javascript
// 创建工作流
export const createWorkflow = (workflowData) => {
  return service.post('/workflows', workflowData)
}

// 更新工作流
export const updateWorkflow = (id, workflowData) => {
  return service.put(`/workflows/${id}`, workflowData)
}

// 获取工作流定义
export const getWorkflowDefinition = (id) => {
  return service.get(`/workflows/${id}`)
}
```

## 六、实现步骤

1. **更新数据库结构**：

   * 修改 `01-schema.sql`，添加 `definition` 字段到 `workflow` 表

   * 删除 `workflow_node` 和 `workflow_edge` 表

2. **更新后端代码**：

   * 修改 Workflow 实体类，添加 `definition` 字段

   * 重写 WorkflowServiceImpl.java，简化方法实现

   * 更新 WorkflowController.java，调整API参数

   * 修改 WorkflowMapper，简化SQL语句

3. **重写前端组件**：

   * 重写 WorkflowDesigner.vue，适配新JSON结构

   * 重写 WorkflowDesignerView\.vue，简化API调用

   * 更新 workflow\.js，调整API函数

4. **测试验证**：

   * 测试新建工作流功能

   * 测试编辑工作流功能

   * 测试保存和加载功能

   * 测试工作流运行功能

## 七、预期效果

1. **简化数据结构**：统一使用JSON格式，减少表数量和复杂度
2. **更高效的数据流转**：前后端直接传递完整JSON，减少数据转换
3. **更简洁的代码**：移除冗余的节点/边处理逻辑
4. **更好的扩展性**：新结构更易于添加新的节点类型和配置
5. **更高效的存储**：减少数据库表关联查询，提高性能

## 八、注意事项

1. **数据库迁移**：不需要迁移，用户会重建数据库
2. **向后兼容**：不需要考虑兼容性，优先保证新系统不出错
3. **数据验证**：在前后端添加对JSON结构的验证
4. **错误处理**：完善API调用和JSON解析的错误处理
5. **性能优化**：对大型工作流的JSON处理进行优化

通过这个完整的重写计划，工作流系统将实现前后端直接传输完整JSON定义，简化架构，提高性能和可维护性。
